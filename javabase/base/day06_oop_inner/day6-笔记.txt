一.内部类
	1.什么是内部类
		在类中定义的类, 就是内部类.
	2.为什么使用内部类
		如果创建一个类的对象需要先创建另一个类对象的时候, 就可以把这个类定义为内部类.
		如果一个类想访问另一个类的成员, 也可以定义为另一个类的内部类.
	3.创建内部类对象
		Outer outer = new Outer();	Outer.Inner inner = outer.new Inner();
		Outer.Inner inner = new Outer().new Inner();
	4.成员访问
		内部类可以直接访问外部类的成员, 而外部类不能直接访问内部类的成员.
		内部类对象创建之后, 外部类对象一定存在, 且肯定是一个, 所以内部类对象可以使用外部类对象的成员. 以 外部类名.this.成员名 形式访问
		外部类对象则不能使用内部类对象, 因为外部类对象创建之后内部类对象有可能还没有创建, 就算创建, 也可能不止一个.
		如果在外部类中一定要访问内部类的成员, 先创建一个内部类对象. 再通过对象访问其成员.
	5.class文件名:
		外部类名$内部类名.class
		
二.方法中的内部类
	1.为什么类要定义在方法中:
		如果一个类只在某个方法中使用, 那么就可以定义在方法中.
	2.class文件名
		外部类名$编号内部类名
	3.使用方式
		方法中的内部类必须先定义再使用, 定义的代码必须在使用的代码上面.
		因为方法是从上到下运行的, 需要先运行到定义类的代码, 后面才能使用.
	4.多个类嵌套使用
		在方法中创建一个类的对象, 先会找方法中的内部类.
		如果没有, 则会找普通内部类.
		如果还没有, 则会找外部类.
		再没有, 则报错.
	5.访问局部变量
		方法中的内部类不能直接访问方法中的局部变量.
		因为内部类对象的生命周期有可能比局部变量生命周期要长. 局部变量在方法结束的时候, 就会被销毁. 而内部类对象仍然可能有其他引用到达.
		为了在这种情况下不出错, 需要将局部变量的生命周期延长, 所以使用final修饰.
		方法中的内部类访问方法中局部变量, 变量必须声明为final.
		
三.静态内部类
	1.普通内部类的静态声明
		普通内部类中不能有静态的声明.
		静态的成员本意就是不创建对象(类加载后)就能使用.
		而内部类必须要创建外部类对象才能使用, 如果在内部类中定义静态成员, 就违背了静态的本意.
	2.静态内部类创建
		创建静态内部类, 不需要创建外部类.
		Outer.Inner inner = new Outer.Inner();
	3.为什么使用静态内部类
		如果一个内部类需要定义静态成员, 那么就可以使用静态内部类.
	4.静态内部类中调用外部成员
		静态内部类中不论是否静态的方法, 都不能调用外部非静态的成员.
		因为静态内部类可以在不创建外部类的情况下创建对象, 没有外部类对象, 就不能调用外部类的成员.
		
***** 四.继承
	1.什么是继承
		一个类可以使用extends关键字继承另外一个类
		被继承的类是父类(超类,基类)
		继承的类是子类(派生类)
		子类会自动继承父类所有的方法和属性
	2.为什么用继承
		当我们发现一个类的功能不够用时, 需要添加方法时.
		当我们定义一个类时需要其他类的功能(方法)的时候.
		代码复用
	3.多个类继承
		Java只支持单继承, 不支持多继承. 因为如果多个类有相同的方法, 都继承过来之后会产生冲突.
		Java可以支持多重继承, 也就是一个类继承另一个类, 另一个再继承其他类.
		
五.类型转换
	*** 1.向上转型
		子类可以当做父类来用, 因为父类有的功能子类都有.
		而父类不能当子类用, 因为子类有的父类不一定有.
		在程序中可以使用一个父类类型的变量引用子类对象, 这叫向上转型.
		在向上转型时, 使用父类变量, 不能调用子类特有方法. 因为编译器检查时会报语法错误.
	*** 2.强制类型转换
		在向上转型时, 使用父类变量引用子类对象, 不能调用子类特有方法, 如果一定要调用, 那么可以强制类型转换.
		使用 (类型) 的形式将一个父类变量转换为子类变量.
		在强制类型转换的时候, 编译器无法判断被转对象的类型. 这时如果被转对象不能强制转换为要转的类型, 运行时会报错.
		为了避免这种错误, 我们一般在强转之前都要使用 instanceof 来判断一下要转的对象是否是指定类型.
	3.向上转型时遇到的问题
		在子类当做父类来用的时候, 用父类变量记住一个子类对象.
		这种情况下, 使用父类变量调用方法, 会调用子类的方法, 因为这个变量中记住的是子类对象的地址. JVM虚拟机的动态绑定.
		而这种动态绑定的机制没有被使用到类的属性中, 因为java希望我们将所有的属性私有化, 也就不会被继承, 就不会出现这种问题.

* 六.匿名内部类
	1.什么是匿名内部类
		如果一个类只使用一次, 那么就可以使用匿名内部类.
	2.定义的格式
		new 父类类型(){
			类定义
		}
		这样做是做了两件事, 先定义了一个类继承于指定父类, 然后使用这个类创建了一个对象
		
错误提示
	InnerClassInMethodDemo.java:28: local variable x is accessed from within inner class; needs to be declared final
                                System.out.println(x);
	28行: 变量x在一个内部类中被访问, 需要声明为final
	
	
	StaticInnerClassDemo.java:16: inner classes cannot have static declarations
                static String name;
	16行: 内部类中不能有静态的声明
                
                
	Exception in thread "main" java.lang.ClassCastException: Typist
        at Inherit1.main(Inherit1.java:35)
	35行: 类型转换异常, 要转换的类是 Typist