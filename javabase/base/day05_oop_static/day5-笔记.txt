* 一.构造函数
	1.构造函数的特征:
		构造函数是一个特殊的函数, 在创建对象的时候运行
		没有返回值类型
		函数名和类名相同
		不能在构造函数中返回一个值, 但可以使用return关键字结束函数
	2.构造函数的执行过程
		Person p = new Person();
		先在栈内存创建变量p
		加载类 Person.class
		在堆内存创建对象
		初始化成员变量, 引用数据类型是null, 基本数据类型是0
		运行构造函数
		变量p引用对象的地址
	3.默认构造函数
		只要创建对象, 一定会调用构造函数. 
		如果不写任何构造函数, 会生成一个默认无参的空的构造函数.
		如果写了任何一个构造函数, 就不会再生成默认的了.
		为了方便别人创建对象, 当我们写有参构造函数时, 最好把无参的也写上. (标准的JavaBean)
	4.构造函数的访问权限
		一般构造函数都定义为public的, 所有类都能使用. 如不写则是默认, 默认权限只能相同的包中使用.
		如果一个类不想让别人创建对象, 可以声明为private的构造函数. 例如: 单态设计模式
	5.构造函数之间的调用
		在构造函数中, 可以使用this()形式调用其他构造函数.
		this()只能写在第一个语句.
		注意不要形成递归调用.
		
* 二.this关键字
	1.this的特征:
		this用在方法中
		是一个对象引用
		谁调用方法, 就引用谁
	2.this的应用场景:
		a).指定调用类的成员的时候
		b).构造函数中使用this()形式调用其他构造函数
		c).将调用方法的对象本身作为一个参数传递给其他函数
		d).在内部类中使用(以后再讲)

* 三.参数传递
	1.基本数据类型
		由于基本数据类型直接存储在变量中, 当做实参传入方法后, 方法中的形参里保存的就是基本数据类型的值.
		在方法中对形参修改, 调用处的实参不受影响.
	2.引用数据类型
		由于引用数据类型是将地址存储在变量中, 当做实参传入方法后, 方法中的形参里保存的就是引用数据类型的地址.
		在方法中对形参修改, 修改的是同一个地址上的对象, 所以调用处的实参也受影响.
		
四.Static
	* 1.静态变量
		静态变量被类的所有实例所共享
		静态变量可以直接使用 类名.变量名 形式访问
		静态变量在类加载时初始化. (类在第一次被使用的时候加载)
	* 2.静态方法
		静态方法在类加载后就可以使用
		静态方法可以直接使用 类名.方法名 形式访问
		静态方法中不能访问外部非静态成员. 因为静态方法在类加载后就可以使用了, 而其他非静态成员必须创建对象之后才能用.
		如果一定要在静态方法中使用非静态成员, 可以先创建对象再使用
		静态方法中不能使用this关键字, 因为this是一个引用, 哪个对象调用方法就引用哪个对象, 而静态方法有可能不被任何对象调用, 所以this有可能引用不到.
		如果一个方法不需要访问该类的属性, 那么就可以定义为静态方法, 这样别人不用创建对象就可以直接访问方法, 方便别人使用.
	3.静态代码块
		类加载时就执行的代码
		由于类只在第一次使用的时候加载, 静态代码块中的代码只执行一次
	4.对象创建流程(最终版)
		Person p = new Person();
		栈内存创建变量
		在名称空间中检查是否有Person.class, 有则不加载, 没有则加载
		处理静态成员. 初始化静态变量, 运行静态代码块, 加载静态方法. 静态变量初始化和静态代码块顺序按代码从上到下顺序执行
		堆内存创建对象, 初始化成员变量, 运行普通代码块, 加载非静态方法
		运行构造函数
		变量记住对象地址
			
五.垃圾回收
	1.finalize()
		在对象被销毁之前会自动调用finalize()方法
		finalize()方法在每个类中都会有, 因为这个方法在Object类中定义.
		Object是所有类的父类, 所有类都会继承Object类中的方法.
	2.gc()
		JVM虚拟机处理垃圾的机制是由垃圾的量来决定的, 当虚拟机中的垃圾对象足够多时, 就开始处理垃圾了.
		如果我们想将虚拟机中的垃圾对象全部清除, 可以使用System.gc()方法通知虚拟机清理垃圾(需要时间).
		
		

报错
	ConstructorDemo.java:38: cannot return a value from method whose result type is void
                return name;
	38行: 不能在一个返回值类型为空的方法中返回一个值(构造函数不写返回值, 虚拟机认为其是一个返回值类型为void的函数)
	
	
	ConstructorDemo.java:46: invalid method declaration; return type required
        run(){
	46行: 错误方法声明, 返回值类型必须(除了构造函数, 其他函数都必须有返回值类型)        
	
	
	ConstructorDemo1.java:39: call to this must be first statement in constructor
                this();
	39行: this只能在构造函数的第一个语句使用
	
	
	ConstructorDemo1.java:28: recursive constructor invocation
        A(int i, String s){
	28行: 递归(自己调用自己)的构造函数调用(形成了死循环)
	
	
	StaticMethod.java:22: non-static variable name cannot be referenced from a static context
                System.out.println(name + " ????????");
	22行: 非静态的变量name不能被引用到一个静态的内容中