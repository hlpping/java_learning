一.多线程概念
	1.进程与线程
		一个程序启动, 至少会有一个进程, 一个进程中至少有一个线程.
	2.创建线程
		a).写一个类继承Thread, 重写run方法(), 在子类的run()方法中写线程要做的事. 创建子类对象, 调用start()方法.
			这时程序会开启一条新的线程, 在新的线程上运行run()方法.
		b).写一个类实现Runnable接口, 创建Thread类对象时在构造函数中传入Runnable对象, 在调用start()方法时, 就会调用Runnable的run()方法.
	3.线程交替
		在多线程并发的时候, CPU同一时间内只能为一条线程工作, 多条线程共同竞争CPU资源.
		如果多个线程中做的事都是不停的占用CPU, 那么多线程并发并不能提高效率.
		如果多个线程中做的事都是做一会停一会, 那么多线程并发会提高效率. 这样会提高CPU的使用率.
		
二.常用API
	1.sleep
		控制当前线程休眠, 实参单位为毫秒
		Thread.sleep(1000); 	// 休眠1000毫秒
	2.setDaemon()
		设置当前线程为守护线程, 程序中的守护线程不会单独运行, 如果程序中所有非守护线程都执行结束, 那么程序直接退出.
		注意要在线程开启直线设置.
	3.join()
		当前线程暂停, 加入一条其他线程, 等待该线程运行结束, 当前线程继续运行.
	4.currentThread()
		获取当前线程
	5.getName(), setName()
		获取, 设置线程的名字

三.线程的同步
	1.线程安全问题
		多线程并发操作同一数据时, 有可能出现线程安全问题.
	2.同步代码块
		使用关键字 synchronized(){} 来定义一个同步代码块.
		多条线程中如果遇到同步代码块而且使用相同的锁旗标时, 只能有1条线程进入, 其他等待, 直到这条线程将同步代码块中的代码执行完毕, 其他线程才能进入.
	3.同步方法
		使用 synchronized 关键字修饰一个方法, 那么整个方法中的代码都是同步的
		同步方法使用的锁旗标是this
	4.死锁
		在多个同步代码块中互相调用时, 容易产生死锁.
		在多线程同步的时候, 如果需要使用多个锁, 尽量避免嵌套使用, 不要产生死锁. 
		
四.线程的通信
	1.等待
		锁旗标.wait()方法可以控制当前线程等待, 任何对象都有这个方法, 因为该方法是声明在Object类中的.
		wait()之后, 当前线程会让出cpu资源, 直到被其他线程唤醒时继续.
	2.唤醒
		锁旗标.notify()方法可以唤醒在制定锁旗标上等待的随机一个线程, 这个方法也是声明在Object类中的.
		notify()是唤醒随机一个
		notifyAll()唤醒所有的
		
五.JDK5的线程处理
	1.同步
		使用ReentrantLock的lock()方法开始同步, unlock()方法结束同步.
	2.通信
		使用Condition类的await()和signal()来等待和唤醒, Condition类对象可以通过Lock类的newCondition()获取.
		
线程总结
	1.启动线程
		一般使用Runnable形式, 创建Thread类对象, 在构造函数中传入一个Runnable接口的子类, 那么当调用Thread对象的start()方法时, 就会调用Runnable的run()
	2.线程的同步
		一般使用同步代码块 synchronized(){} 注意多个需要同步的线程必须使用同一个锁旗标
		如果一个方法中所有代码都需要同步, 那么可以使用同步方, 同步方法使用的锁旗标是this
		
		
		
练习:
	编写程序, 定义两个线程交替打印数字
	线程1先打印5次, 线程2再打印5次. 总共交替循环5次.
	运行处如下结果
	